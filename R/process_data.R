# WARNING - Generated by {fusen} from dev/station_pig_monitor.Rmd: do not edit by hand

#' Process Data Frame or Data Table
#' 
#' This function performs various checks and transformations on a provided data frame or data table.
#' It checks for necessary columns, correct data types, and performs various operations like filtering, 
#' joining, and calculating sequences.
#' 
#' @param data A data frame or data table that must contain specific columns with specific data types.
#'             Required columns are: "animal_number", "lifenumber", "responder", "location", "visit_time",
#'             "duration", "state", "weight", "feed_intake".
#'
#' @return Returns a modified data table with computed sequence features and potentially other transformations.
#'         The function ensures that columns are of the correct type and that data integrity is maintained.
#' 
#' @export
#' 
#' @note This function will stop execution and produce an error if the input data does not meet the expected
#'       requirements, such as missing columns or incorrect data types.
#' @examples
#' # Load CSV data
#' data <- data.table::fread("C:/Users/Dell/Documents/projects/pptsdm_data/ppt_monitor_test_data.csv")
#' processed_data <- process_data(data = data)
#' head(processed_data)
process_data <- function(data) {
  if (missing(data)) stop("Missing data frame or data table!")
  if (!is.data.frame(data) && !inherits(data, "data.table")) stop("Data is not a data frame or data table!")
  #if (!is.data.frame(data) && !class(data) == 'data.table')
  # Check for required columns
  required_columns <- c("animal_number", "lifenumber", "responder", "location", "visit_time", "duration", "state", "weight", "feed_intake")
  missing_columns <- setdiff(required_columns, names(data))
  if (length(missing_columns) > 0) stop(paste("Missing columns:", paste(missing_columns, collapse = ", ")))

  # Check types for some columns
  if (!is.numeric(data$animal_number) && !is.character(data$animal_number)) stop("'animal_number' must be numeric or character!")
  if (!is.logical(data$lifenumber) && !is.character(data$lifenumber)) stop("'lifenumber' must be logical or character!")
  if (!is.numeric(data$responder) && !is.character(data$responder)) stop("'responder' must be numeric or character!")
  if (!is.numeric(data$location)) stop("'location' must be numeric!")
  if (!is.character(data$visit_time) && !inherits(data$visit_time, "POSIXt")) stop("'visit_time' must be character or POSIXct!")
  if (!is.numeric(data$duration)) stop("'duration' must be numeric!")
  if (!is.numeric(data$state)) stop("'state' must be numeric!")
  if (!is.numeric(data$weight)) stop("'weight' must be numeric!")
  if (!is.numeric(data$feed_intake)) stop("'feed_intake' must be numeric!")

  # Check if the data is a data.frame, if yes, then make a deep copy of the data and convert it into data.table
  if (is.data.frame(data)) data <- data.table::as.data.table(data.table::copy(data))

  responder <- weight <- . <- location <- N <- n <- location_maxn <- visit_time <- seq_days <- seq_in_day <- seq_in_location <- feed_intake <- NULL

  # Filter out the data with NA in 'responder' column and remove duplicates
  data_temp <- unique(data)[!is.na(responder)]

  # Create a unique data.table for 'responder' and 'location'
  unique_dt <- unique(data_temp[, .(responder, location)])

  # Find duplicate 'responder's
  dup_responders <- unique_dt[, .N, by = .(responder)][N > 1]

  # Compute the number of records for each 'responder' and 'location'
  num_records <- unique(data_temp[, `:=`(n, .N), .(responder, location)][, .(responder, location, n)])

  # Set 'responder' as the key for join operations
  data.table::setkey(dup_responders, responder)
  data.table::setkey(num_records, responder)

  # Perform left join operation on 'num_records' and 'dup_responders'
  dup_records <- num_records[dup_responders]

  # Modify the 'location' in the unique data.table for duplicate 'responder's
  if(nrow(dup_responders) > 0) {
    # Compute the 'location' with maximum number of records for each 'responder'
    max_n_location <- num_records[, .(max_n = max(n), location_maxn = location[which.max(n)]), by = responder]

    # Remove duplicates in 'max_n_location' after modifying 'location'
    max_n_location <- unique(max_n_location)

    # Perform left join operation on 'data_temp' and 'max_n_location' and update 'location' to 'location_maxn'
    data_temp <- merge(data_temp, max_n_location, by = "responder", all.x = TRUE)[, location := location_maxn][, c("max_n", "location_maxn") := NULL]
  }

  # Preprocess data and compute sequence features
  # Check the class of visit_time
  if(is.character(data_temp$visit_time)) {
    # If visit_time is a character vector, replace "/" with "-"
    data_temp[, visit_time := gsub("/", "-", visit_time)]
    data_pre <- data_temp[, `:=`(c("date", "time"), data.table::IDateTime(visit_time))]
  } else {
    # If visit_time is not a character vector, assume it's a datetime object
    data_pre <- data_temp[, `:=`(c("date", "time"), data.table::IDateTime(visit_time))]
  }
  data_pre <- data_pre[data.table::CJ(date = tidyr::full_seq(date, 1)), on = .(date)  # Compute complete sequence of dates
  ][order(date), `:=`(seq_days, .GRP), by = date  # Compute sequence number of days
  ][order(visit_time), `:=`(seq_in_day, 1:.N), by = .(responder, date)  # Compute sequence number in day
  ][order(visit_time), `:=`(seq_in_location, 1:.N), by = .(location, date)  # Compute sequence number in location
  ][order(responder, visit_time)  # Order data by 'responder' and 'visit_time'
  ][, .(responder, location, date, seq_days, seq_in_day, seq_in_location, feed_intake, weight)  # Keep only necessary columns #seq_in_location, seq_days, seq_in_day,, weight
  ][, `:=` (responder = as.character(responder),  # Convert 'responder' and 'location' to character type
            location = as.character(location),
            feed_intake = as.numeric(feed_intake),
            weight = as.numeric(weight))][!is.na(location)][]  # Convert 'weight' to numeric type
  return(data_pre)
}
