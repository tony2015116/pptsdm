# WARNING - Generated by {fusen} from dev/station_pig_monitor.Rmd: do not edit by hand

#' Table Monitor Function
#'
#' The `table_monitor` function processes input data and generates an Excel workbook 
#' with various monitoring statistics and conditional formatting. It is designed for 
#' analyzing and visualizing data related to house monitoring, feed intake, and other 
#' relevant metrics over a specified period.
#'
#' @param data data.frame, required.
#'   The input data frame containing the data to be processed.
#' @param house_width character, optional.
#'   A character string representing the house width. Default is "1".
#' @param days integer, optional.
#'   An integer representing the number of days for the analysis.
#' @param ref_date Date, optional.
#'   A Date object representing the reference date. Default is the current date 
#'   (`Sys.Date()`).
#' @param save_path character, required.
#'   A character string representing the path where the Excel file will be saved. 
#'   Must be a non-empty string ending with ".xlsx".
#'
#' @return A list containing various monitoring statistics:
#' \itemize{
#'   \item `responder_na`: Data frame with responder NA statistics.
#'   \item `extreme_weight`: Data frame with extreme weight outlier statistics.
#'   \item `feed_time_n`: Data frame with feed time statistics.
#'   \item `low_feedintake`: Data frame with low feed intake statistics.
#'   \item `all_feedintake`: Data frame with all feed intake statistics.
#'   \item `mean_feedintake`: Data frame with mean feed intake statistics.
#'   \item `house_weight`: Data frame with house weight statistics.
#'   \item `visit_n_hour`: Data frame with the number of visits per hour.
#'   \item `feed_time_hour`: Data frame with feed time per hour.
#'   \item `feed_intake_hour`: Data frame with feed intake per hour.
#' }
#'
#' @import data.table
#' @import openxlsx
#' @importFrom stats "quantile" "time"
#' @export
#' 
#' @note
#' The `save_path` parameter must be a valid path ending with ".xlsx". Ensure that 
#' the `data` parameter is a data frame and contains the necessary columns for 
#' processing.
#' @examples
#' # Load CSV data
#' data <- data.table::fread("C:/Users/Dell/Documents/projects/pptsdm_data/ppt_monitor_test_data.csv")
#' # Monitor station and data
#' res <- table_monitor(data = data, days = 5, save_path = "C:/Users/Dell/Downloads/test")
#' # Monitor the number of times 'na' appears in the last n days
#' head(res$responder_na)
#' # Monitor the percentage of extreme weight records in the last n days
#' head(res$extreme_weight)
#' # Monitor the visiting time and frequency of pigs in the last n days
#' head(res$feed_time_n)
#' # Monitor the low feedintake over the last n days
#' head(res$low_feedintake)
#' # Monitor the total feed intake over the last n days
#' head(res$all_feedintake)
#' # Monitor the average feed intake over the last n days
#' head(res$mean_feedintake)
#' # Monitor the average weight per pen over the last n days
#' head(res$house_weight)
#' # Monitor visit time in each hour over the last 1 day.
#' head(res$visit_n_hour)
#' # Monitor feed intake time in each hour over the last 1 day.
#' head(res$feed_time_hour)
#' # Monitor feed intake in each hour over the last 1 day.
#' head(res$feed_intake_hour)
table_monitor <- function(data, house_width = "1", days, ref_date = Sys.Date(), save_path) {
  
  # Check parameters
  if (missing(data) || is.null(data)) stop("data cannot be NULL")
  if (is.data.frame(data)) data <- data.table::as.data.table(data.table::copy(data))
  if (is.null(house_width)) stop("house_width cannot be NULL")
  if (is.numeric(house_width)) house_width <- as.character(house_width)
  if (is.null(days)) stop("days cannot be NULL")
  if (is.character(days)) days <- as.integer(days)
  
  # Check ref_date parameter
  if (!lubridate::is.Date(ref_date)) {
    stop("ref_date must be a valid date")
  }
  
  # Check save_path parameter
  if (missing(save_path) || is.null(save_path) || !is.character(save_path)) {
    stop("save_path must be a non-empty string ending with '.xlsx'")
  }
  
  # Processing data
  data <- unique(data)
  with_responder_na <- responder_na(data, days, ref_date)
  with_extreme_time_n <- extreme_time_n(data, days, ref_date)
  with_process_data <- process_data(data)
  with_low_feedintake <- low_feedintake(data, days, ref_date)
  with_all_feedintake <- all_feedintake(data, days, ref_date)
  with_number_location <- number_location(data, house_width, days, ref_date)
  with_house_feedintake <- house_feedintake(data, house_width, days, ref_date)
  with_merge_data <- merge_data(with_house_feedintake, with_number_location)
  with_house_weight <- house_weight(data, house_width, days, ref_date)
  with_hour_stat <- hour_stat(data, target_date = ref_date - 1)
  
  all_monitor <- list(
    responder_na = with_responder_na,
    extreme_weight = with_extreme_time_n$weight_outlier,
    feed_time_n = with_extreme_time_n$feedintake,
    low_feedintake = with_low_feedintake,
    all_feedintake = with_all_feedintake,
    mean_feedintake = with_merge_data,
    house_weight = with_house_weight,
    visit_n_hour = with_hour_stat$visit_n,
    feed_time_hour = with_hour_stat$feed_time,
    feed_intake_hour = with_hour_stat$feed_intake
  )
  
  # Create a new xlsx file
  wb <- openxlsx::createWorkbook()
  
  # Loop through each sheet name in the all_monitor list
  for (sheet_name in names(all_monitor)) {
    data <- all_monitor[[sheet_name]]  # Extract the data for the current sheet
    
    # Add a worksheet to the workbook
    openxlsx::addWorksheet(wb, sheet_name)
    
    # Write the data to the worksheet
    openxlsx::writeData(wb, sheet = sheet_name, data, rowNames = FALSE, colNames = TRUE)
    
    # Define different rules for different data frames if needed
    if (sheet_name == "responder_na") {
      # Calculate the 25th, 50th, and 75th percentiles for the column sum_na
      q1 <- quantile(data$total_nas, 0.25, na.rm = TRUE)
      q2 <- quantile(data$total_nas, 0.5, na.rm = TRUE)
      q3 <- quantile(data$total_nas, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = ncol(data), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#63BE7B", "#FFEB84", "#F8696B"))
    } else if (sheet_name == "extreme_weight") {
      # Calculate the 25th, 50th, and 75th percentiles for the entire data frame
      data_values <- unlist(data[, 2:ncol(data)], use.names = FALSE)
      q1 <- quantile(data_values, 0.25, na.rm = TRUE)
      q2 <- quantile(data_values, 0.5, na.rm = TRUE)  # Median
      q3 <- quantile(data_values, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = 2:(ncol(data) + 1), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#63BE7B", "#FFEB84", "#F8696B"))
    } else if (sheet_name == "all_feedintake") {
      # Calculate the 25th, 50th, and 75th percentiles for the column sum_feed_intake
      q1 <- quantile(data$all_feedintake, 0.25, na.rm = TRUE)
      q2 <- quantile(data$all_feedintake, 0.5, na.rm = TRUE)
      q3 <- quantile(data$all_feedintake, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = ncol(data), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#F8696B", "#FFEB84", "#63BE7B"))
    } else if (sheet_name == "mean_feedintake") {
      # Select columns with names containing "mean"
      mean_cols <- grep("mean_feed", colnames(data), value = TRUE)
      n_cols <- length(mean_cols)
      
      # Calculate the 25th, 50th, and 75th percentiles for the entire data frame
      data_values <- unlist(data[, ..mean_cols], use.names = FALSE)
      q1 <- quantile(data_values, 0.25, na.rm = TRUE)
      q2 <- quantile(data_values, 0.5, na.rm = TRUE)  # Median
      q3 <- quantile(data_values, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = (ncol(data) - n_cols + 1):ncol(data), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#F8696B", "#FFEB84", "#63BE7B"))
    } else if (sheet_name == "house_weight") {
      # Calculate the 25th, 50th, and 75th percentiles for the entire data frame
      data_values <- unlist(data[, 2:ncol(data)], use.names = FALSE)
      q1 <- quantile(data_values, 0.25, na.rm = TRUE)
      q2 <- quantile(data_values, 0.5, na.rm = TRUE)  # Median
      q3 <- quantile(data_values, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = 2:(ncol(data) + 1), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#F8696B", "#FFEB84", "#63BE7B"))
    } else if (sheet_name %chin% c("visit_n_hour", "feed_time_hour", "feed_intake_hour")) {
      # Calculate the 25th, 50th, and 75th percentiles for the entire data frame
      numeric_columns <- sapply(data, is.numeric)
      data_values <- unlist(data[, ..numeric_columns], use.names = FALSE)
      q1 <- quantile(data_values, 0.25, na.rm = TRUE)
      q2 <- quantile(data_values, 0.5, na.rm = TRUE)  # Median
      q3 <- quantile(data_values, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = 2:(ncol(data) + 1), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#F8696B", "#FFEB84", "#63BE7B"))
    } else if (sheet_name == "low_feedintake") {
      # Calculate the 25th, 50th, and 75th percentiles for the entire data frame
      numeric_columns <- sapply(data, is.numeric)
      data_values <- unlist(data[, ..numeric_columns], use.names = FALSE)
      q1 <- quantile(data_values, 0.25, na.rm = TRUE)
      q2 <- quantile(data_values, 0.5, na.rm = TRUE)  # Median
      q3 <- quantile(data_values, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = 3:(ncol(data) + 1), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#F8696B", "#FFEB84", "#63BE7B"))
    } else {
      # Select columns with names containing "sum_n"
      sum_n_cols <- grep("sum_n", colnames(data), value = TRUE)
      n_cols <- length(sum_n_cols)
      
      # Calculate the 25th, 50th, and 75th percentiles for the entire data frame
      data_values <- unlist(data[, ..sum_n_cols], use.names = FALSE)
      q1 <- quantile(data_values, 0.25, na.rm = TRUE)
      q2 <- quantile(data_values, 0.5, na.rm = TRUE)  # Median
      q3 <- quantile(data_values, 0.75, na.rm = TRUE)
      
      # Add conditional formatting based on the calculated percentiles
      openxlsx::conditionalFormatting(wb, sheet = sheet_name, cols = (ncol(data) - n_cols + 1):ncol(data), rows = 2:(nrow(data) + 1),
                                      rule = c(q1, q2, q3),
                                      type = "colorScale",
                                      style = c("#F8696B", "#FFEB84", "#63BE7B"))
    }
    
    # Create a bold style for column and row names
    header_style <- openxlsx::createStyle(textDecoration = "bold", halign = "center")
    
    # Apply the bold style to column names
    openxlsx::addStyle(wb, sheet = sheet_name, style = header_style, rows = 1, cols = 1:ncol(data), gridExpand = TRUE)
    
    # Create a center alignment style for cell contents
    center_style <- openxlsx::createStyle(halign = "center")
    
    # Apply the center alignment style to cell contents
    openxlsx::addStyle(wb, sheet = sheet_name, style = center_style, rows = 2:(nrow(data) + 1), cols = 1:ncol(data), gridExpand = TRUE)
    
    # Optionally, apply the bold style to row names
    # In this example, assume the first column contains row names
    openxlsx::addStyle(wb, sheet = sheet_name, style = header_style, rows = 1:(nrow(data) + 1), cols = 1, gridExpand = TRUE)
    
    # Auto adjust column widths
    openxlsx::setColWidths(wb, sheet = sheet_name, cols = 1:ncol(data), widths = "auto")
  }
  
  # Save the xlsx file
  openxlsx::saveWorkbook(wb, file.path(save_path, "table_monitor.xlsx"), overwrite = TRUE)
  
  return(all_monitor)
}
